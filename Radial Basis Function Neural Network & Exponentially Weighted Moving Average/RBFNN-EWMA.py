# -*- coding: utf-8 -*-
"""Master.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qcc_0JLzr2o8qSYT4cxJLWhDGL9oRSgP
"""

from sklearn.svm import SVR
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
plt.style.use('seaborn-darkgrid')

from google.colab import files 
uploaded = files.upload() # pakai ini untuk upload menggunakan G-colab (jagan lupa matikan chookie blocker)

df = pd.read_csv('GOOG.csv')
df

actual_price = df.tail(1)
actual_price

df = df.head(len(df)-1)
df

days = list()
adj_close_prices = list()

df_days = df.loc[:, 'Date']
df_adj_close = df.loc[:, 'Adj Close Price']

for day in df_days:
   days.append( [int(day.split('/')[1])] )

for adj_close_price in df_adj_close:
   adj_close_prices.append( float(adj_close_price) )

print(days)

#SVR model using a RBF kernel
rbf_svr = SVR(kernel='rbf', C=1000.0, gamma=0.15)
rbf_svr.fit(days, adj_close_prices)
#Exponential Weighted Moving Average
mean = df_adj_close.ewm(com=0.5).mean()

#Plot the models on a graph to see which has the best fit
plt.figure(figsize=(16,8))
plt.scatter(days, adj_close_prices, color = 'black', label='Original Data')
plt.plot(days, rbf_svr.predict(days), color = 'green', label='RBF Model')
plt.plot(days,mean, color = 'red', label='Moving Average')
plt.xlabel('Days')
plt.ylabel('Adj Close Price')
plt.title('GOOG')
plt.legend()
plt.show()

ama

rb

day = [[123]]
#Menjadikan data menjadi dataList
ma = mean.values.tolist()
rb = rbf_svr.predict(days)
print('Adj Close pada hari Terakhir :',adj_close_prices[-1])
print('Prediksi Menggunakan RBF:  Adj Close pada hari Terakhir', rb[-1])
print('Prediksi Menggunakan MA :  Adj Close pada hari Terakhir', ma[-1])

"""Metode Evaluasi Menggunakan MAD, MSE & MAPE


"""

ama=np.array(ma)

#rb sudah bertipe data array

acp=np.array(adj_close_prices)

#Persiapan Evaluasi Metode Prediksi Xi = ma (untuk menguji EWMA ) / rb (untuk menguji RBF)
Xi=ma
Ai=acp
Pi=np.zeros(123)
n=len(Xi)
#Menghitung nilai Error
error = acp-ma
#Mengubah data error menjadi absolute
errorr=np.absolute(error)
#Mencari nilai Error^2
errorr2 = np.square(errorr)

#MAD Manual
mad=sum(errorr)/n
print( mad,'$')

#MSE Manual
mse=sum(errorr2)/n
print( mse,'$')

#MAPE
ape = (acp-Xi)/acp
mape = np.absolute(ape)
mapee = (sum(mape)/n)*100
print(mapee,'%')

(sum(np.absolute(ape))/n)*100